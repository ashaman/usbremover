{Gets device description from STORAGE_DEVICE_DESCRIPTOR structure}
procedure TDevice.GetAPIDeviceDescription(fHandle: THandle);
var
  DeviceDescriptor: STORAGE_DEVICE_DESCRIPTOR; {system device descriptor}
  ReturnedBytes: DWORD; {buffer for returned bytes}
  PropQuery: STORAGE_PROPERTY_QUERY; {property query}
  Success: LongBool; {indicates if a function call was successful}
  //hDev: THandle; {}
  DskSize: GET_LENGTH_INFORMATION;
begin
    //zero memofy for pointers
    ZeroMemory(@PropQuery, sizeof(PropQuery));
    ZeroMemory(@DeviceDescriptor, sizeof(DeviceDescriptor));
    //getting size of structure
    DeviceDescriptor.Size := sizeof(DeviceDescriptor);
    //we call DeviceIOControl to get info about the device
    //Returned bytes has no meaning in this case
    Success := DeviceIoControl(fHandle,IOCTL_STORAGE_QUERY_PROPERTY,@PropQuery,
      sizeof(PropQuery), @DeviceDescriptor, DeviceDescriptor.Size,
      ReturnedBytes, nil);
    if not Success
    then begin
      raise EDeviceException.Create(SysErrorMessage(GetLastError));
    end {exception - no such device}
    else begin
      if (DeviceDescriptor.BusType = BusTypeUnknown) or
        (DeviceDescriptor.BusType = BusTypeMaxReserved)
      then begin
        raise EDeviceException.Create(SysErrorMessage(GetLastError)); //unknown bus type
      end {unknown bus type}
      else begin
        {Converting bus type to TBusType}
        fDeviceBusType := TDevice.StorageBusTypeToTBusType(DeviceDescriptor.BusType);
        {Getting vendor ID
        fVendorID := self.APICharArrayToPChar(DeviceDescriptor,
          DeviceDescriptor.VendorIdOffset);}
        {Getting product revision
        fProductRevision := self.APICharArrayToPChar(DeviceDescriptor,
          DeviceDescriptor.ProductRevisionOffset);}
        {Getting product ID
        fProductID := self.APICharArrayToPChar(DeviceDescriptor,
          DeviceDescriptor.ProductIdOffset);}
      end;
    end;
    ZeroMemory(@PropQuery, sizeof(PropQuery));
    ZeroMemory(@DeviceDescriptor, sizeof(DeviceDescriptor));
end;




//This function gets device serial number
function TDevice.GetAPISerialNumber(devNumber: Cardinal): PChar;
var
  devHandle: THandle; //device handle
  diskSerialData: MEDIA_SERIAL_NUMBER_DATA; //structure for disk serial data
  Success: LongBool; //boolean flag
  ReturnedBytes: Cardinal; //bytes returned by DeviceIoControl
begin
  Result := '';
  //we open device as file
  devHandle := CreateFile(PChar(DrivePattern+IntToStr(devNumber)),
    0, FILE_SHARE_READ or FILE_SHARE_WRITE, nil, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
  try
    if devHandle = INVALID_HANDLE_VALUE
    then begin
      raise EDeviceException.Create(SysErrorMessage(GetLastError));
    end //opening failed
    else begin
      //here we try to get device serial number
      Success := DeviceIoControl(devHandle,IOCTL_STORAGE_GET_MEDIA_SERIAL_NUMBER,
        nil, 0, @diskSerialData, sizeof(diskSerialData), ReturnedBytes, nil);
      if not Success
      then begin
        raise EDeviceException.Create(SysErrorMessage(GetLastError));
      end //function invoke failed
      else begin
        Result := PChar(@diskSerialData.SerialNumberData);
      end; //successfully invoked
    end; //opening succeeded
  finally
    try
      CloseHandle(devHandle);
    except //handle already closed
    end; //exception supression
  end; //finally
end;

{Converts char arrays to PChar}
function TDevice.APICharArrayToPChar(DeviceDescriptor: STORAGE_DEVICE_DESCRIPTOR;
  offset: Cardinal): PChar;
var
  buf: PChar; {string for buffer}
begin
  Result := '';
  if offset <> 0
  then begin
    buf := @PCharArray(@DeviceDescriptor)^[offset];
    Result := PChar(Trim(buf));
  end;
end;


//Converts integer codes to TBusType enumeration
class function TDevice.StorageBusTypeToTBusType(sBusType: STORAGE_BUS_TYPE): TBusType;
begin
  Result := btUnknown;
  case sBusType of
    BusTypeScsi: Result := btSCSI;
    BusTypeAtapi: Result := btATAPI;
    BusTypeAta: Result := btATA;
    BusType1394: Result := btFireWire;
    BusTypeSsa: Result := btSSA;
    BusTypeFibre: Result := btFibre;
    BusTypeUsb: Result := btUSB;
    BusTypeRAID: Result := btRAID;
    BusTypeiSCSI: Result := btiSCSI;
    BusTypeSas: Result := btSAS;
    BusTypeSata: Result := btSATA;
  end;
end;


//This function gets all logical drives in system
procedure TDeviceManager.GetDrives;
const
  charCount = 4; //four characters describe each drive, e.g.: c:\<null-term>
var
  drives: PAnsiChar; //buffer for driver strings
  pDrives: Pointer; //pointer to the drives array
  bufSize: DWORD; //size of buffer
  i: integer; //counter
  driveNumber: integer; //number of drives
  sizeOfChar: integer; {size of 1 character in bytes:
                       (ANSI - 1 byte, Unicode - 2 bytes)}
begin

  {
    //here we get size needed for buffer
    bufSize := GetLogicalDriveStrings(0,nil);
    if bufSize<>0
    then begin //everything is OK
      drives := AllocMem(bufSize); //we alloc memory
      pDrives := drives; //save pointer to the beginning of the array
      GetLogicalDriveStrings(bufSize,drives);
      sizeOfChar := sizeof(drives[0]);
      driveNumber := (bufSize-1) div charCount; //we count the quantity of drives
      for i := 1 to driveNumber do
      begin
        if FilterDevices(drives)
        then begin
          fDevices.Add(TDevice.Create(drives))
        end; //filter
        drives := drives + charCount*sizeOfChar;  //move to the next list item
      end; //drives
      FreeMem(pDrives,bufSize); //we release resources
    end //bufSize<>0
    else begin
      raise EDeviceException.Create('Initialization failed!');
    end; //Raise
  }
end; //GetDrives


//In this function we get the specified device information by its instance handle
//We get all the devices of the specified class and get one of them
class function TDevice.GetDeviceInformation(InstanceHandle: THandle; DeviceInfoSet: THandle):
  TDeviceInfoData;
var
  buffer: TCharArray; //string buffer
begin
  //get the specified device ID
  if (CM_Get_Device_IDA(InstanceHandle,@buffer,sizeof(buffer),0) <> 0)
  then begin
    raise EDeviceException.Create(SysErrorMessage(GetLastError));
  end //then
  else begin
    //open the specified device information
    if not SetupDiOpenDeviceInfoA(DeviceInfoSet, PChar(@buffer), 0, 0, @Result)
    then begin
      raise EDeviceException.Create(SysErrorMessage(GetLastError));
    end; //then
  end; //else
end; //GetDeviceInformation


{
//This function gets all logical drives in system
procedure TDeviceManager.GetLogicalDrives;
const
  charCount = 4; //four characters describe each drive, e.g.: c:\<null-term>
var
  drives: PAnsiChar; //buffer for driver strings
  pDrives: Pointer; //pointer to the drives array
  bufSize: DWORD; //size of buffer
  i: integer; //counter
  driveNumber: integer; //number of drives
begin
  //clearing the list
  fLogicalDrives.Clear;
  //here we get size needed for buffer
  bufSize := GetLogicalDriveStrings(0,nil);
  if bufSize<>0
  then begin //everything is OK
    drives := AllocMem(bufSize); //we alloc memory
    pDrives := drives; //save pointer to the beginning of the array
    GetLogicalDriveStrings(bufSize,drives);
    driveNumber := (bufSize-1) div charCount; //we count the quantity of drives
    for i := 1 to driveNumber do
    begin
      if FilterDevices(drives) //skipping floppies and CDROM's
      then begin
        fLogicalDrives.Add(drives);
        //fDevices.Add(TDevice.Create(drives));
      end; //filter
      Inc(drives, charCount);  //move to the next list item
    end; //drives
    FreeMem(pDrives,bufSize); //we release resources
  end //bufSize<>0
  else begin
    raise EDeviceException.Create('Initialization failed!');
  end; //Raise
end; //GetDrives
}

{
//This function gets all logical drives in system
procedure TDeviceManager.GetDrives;
var
  devInfo: THandle; //device info handle
  devInfoData: TSPDevInfoData; //device info
  devInterfaceData: TSPDeviceInterfaceData; //device interface info
  devInterfaceDefailData: TSPDeviceInterfaceDetailData; //concrete info
  i: integer; //counter
  dwSize: Cardinal; //dummy integer
begin
  //First, we get all disk devices in the system. Then, we choose
  //which are removable and then add them to the device list
  devInfo := SetupDiGetClassDevsA(@GUID_DEVCLASS_DISKDRIVE, nil, HWND(nil),
    DIGCF_PRESENT or DIGCF_DEVICEINTERFACE);
  if devInfo = INVALID_HANDLE_VALUE
  then begin
  end //then
  else begin
    i := 0;
    devInterfaceData.cbSize := sizeof(devInterfaceData);
    while (SetupDiEnumDeviceInterfaces(devInfo,nil,GUID_DEVCLASS_DISKDRIVE,
      i,devInterfaceData)) do
    begin
      inc(i);
      SetupDiGetDeviceInterfaceDetailA(devInfo,@devInterfaceData,nil,0,dwSize,nil);
      if dwSize = 0
      then begin
      end //fail
      else begin
        devInfoData.cbSize := dwSize;
        devInterfaceDefailData.cbSize := 5;
        SetupDiGetDeviceInterfaceDetailA(devInfo,@devInterfaceData,
          @devInterfaceDefailData,dwSize,dwSize,nil);

          ////!!!!!!!!!!!Look for SafeRemove by Bagel
          //// the previous works good

      end;
    end; //while
  end; //else
end; //GetDrives}


function TDeviceManager.GetLogicalDrives(const Volumes: TStrings): TStrings;
var
  dummy: Cardinal;
  s: string;
  handle: THandle;
  buf: TVolumeDiskExtents;
  i: integer;
begin


  for i := 0 to Volumes.Count-1 do
  begin
    s := Volumes.Strings[i];
    s[3] := '.';
    Delete(s,Length(s),1);
    handle := CreateFile(PChar(s),GENERIC_READ, FILE_SHARE_READ
      or FILE_SHARE_WRITE, nil, OPEN_EXISTING, 0, 0);
    if handle <> INVALID_HANDLE_VALUE
    then begin
      if DeviceIoControl(handle,IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS, nil,0,
        @buf,sizeof(buf),dummy,nil)
      then begin
        dummy := buf.Extents[0].DiskNumber;
      end;
      CloseHandle(handle);
    end;
  end;
end;


unit Device;

interface
uses
  WinIOCtl, Classes, WbemScripting_TLB;

type
  {all kinds of devices defined in WinAPI enums}
  TBusType = (btSCSI, btATAPI, btATA, btFireWire, btSSA, btFibre, btUSB,
  btRAID, btiSCSI, btSAS, btSATA, btUnknown);

  //CLASS-WRAPPER FOR DEVICE
  TDevice = class(TObject)
  private
    fDeviceID: string; //device ID
    fDeviceNumber: Cardinal; //device number in system
    fDeviceNumberOfPartitions: integer; //number of drive partitions
    fDeviceManufacturer: string; //device manufacturer
    fDeviceModel: string; //device model
    fDeviceBusType: string; //device bus type
    fDeviceName: string; //device name
    fDeviceVolumes: TList; //device volume
    //These functions get disk partition information and its device number
    class function GetAPIDeviceNumber(fHandle: THandle): Cardinal;
    procedure GetAPIDeviceDescription(devNumber: Cardinal);
    procedure SetDeviceProperty(devProperty: ISWbemProperty);
    {getters}
    function GetDeviceID: string;
    function GetDeviceNumber: Cardinal;
    function GetDeviceNumberOfPartitions: Integer;
    function GetDeviceManufacturer: string;
    function GetDeviceModel: string;
    function GetBusType: string;
    function GetDeviceName: string;
    {end getters}
  public
    constructor Create(path: PChar);
    destructor Destroy; override;
    //properties
    property DeviceID: string read GetDeviceID; {Device ID}
    property DeviceNumber: Cardinal read GetDeviceNumber; {physical drive number}
    property DeviceNumberOfPartitions: integer read GetDeviceNumberOfPartitions; {number of partitions}
    property DeviceManufacturer: string read GetDeviceManufacturer; {device manufacturer}
    property DeviceModel: string read GetDeviceModel; {Model}
    property DeviceBusType: string read GetBusType; {Bus type}
    property DeviceName: string read GetDeviceName; {Name}
  end;

{==============================================================================}
implementation
uses
  Windows, DeviceException, SysUtils, WMI, OleServer, ActiveX;

//This function gets device number
class function TDevice.GetAPIDeviceNumber(fHandle: THandle): Cardinal;
var
  Success: LongBool; //boolean flag
  devNumber: TStorageDeviceNumber; //structure which describes device number
  ReturnedBytes: Cardinal; //bytes returned by DeviceIoControl
begin
  //call DeviceIOControl
  Success := DeviceIoControl(fHandle,IOCTL_STORAGE_GET_DEVICE_NUMBER,
    nil, 0, @devNumber, sizeof(TStorageDeviceNumber), ReturnedBytes, nil);
  if not Success
  then begin
    raise EDeviceException.Create(SysErrorMessage(GetLastError));
  end //getting device number failed
  else begin
    Result := devNumber.DeviceNumber;
  end; //successful
end;

//gets property name and sets the value
procedure TDevice.SetDeviceProperty(devProperty: ISWbemProperty);
begin
  if devProperty.Name = 'DeviceID'
  then begin
    fDeviceID := devProperty.Get_Value;
    exit;
  end;
  if devProperty.Name = 'InterfaceType'
  then begin
    fDeviceBusType := devProperty.Get_Value;
    exit;
  end;
  if devProperty.Name = 'Manufacturer'
  then begin
    fDeviceManufacturer := devProperty.Get_Value;
    exit;
  end;
  if devProperty.Name = 'Model'
  then begin
    fDeviceModel := devProperty.Get_Value;
    exit;
  end;
  if devProperty.Name = 'Name'
  then begin
    fDeviceName := devProperty.Get_Value;
    exit;
  end;
  if devProperty.Name = 'Partitions'
  then begin
    fDeviceNumberOfPartitions := Cardinal(devProperty.Get_Value);
    exit;
  end;
  {
    if devProperty.Name = 'PNPDeviceID'
    then begin
      buf := TStringList.Create;
      ExtractStrings(['\','&'],[], PChar(string(devProperty.Get_Value)), buf);
      exit;
    end;
    //string SerialNumber; not supported on XP
    //uint64 Size;
    //string Caption;
    //string Description;
    //string FirmwareRevision; not available on XP
  }
end;

{Gets device description from WMI}
procedure TDevice.GetAPIDeviceDescription(devNumber: Cardinal);
var
  Locator: TSWbemLocator; //OLE provider
  Services: ISWbemServices; //namespace objects
  ObjectSet:  ISWbemObjectSet; //query result - set of objects
  ObjectSetItem: ISWbemObject; //item of the ObjectSet
  Enumerator: IEnumVariant; //device enumerator
  PropertyEnumerator: IEnumVariant; //device properties enumerator
  PropertySet: ISWbemPropertySet; //device properties set
  OleObject: OleVariant; //buffer for getting device info
  DeviceProperty: ISWbemProperty; //device property
  ReturnNumber: Cardinal; //return parameter of procedure call
begin
  //we create OLE provider
  Locator := TSWbemLocator.Create(nil);
  //we connect to the local computer namespace
  Services := Locator.ConnectServer('.','root\CIMV2','','','','',0,nil);
  //we execute query to get the only device we need
  ObjectSet := Services.ExecQuery('SELECT * FROM Win32_DiskDrive WHERE DeviceID="'+
    Format(DrivePattern,[devNumber])+'"','WQL',wbemFlagReturnImmediately
    and wbemFlagForwardOnly, nil);
  //we get the device enumerator
  Enumerator := (ObjectSet._NewEnum) as IEnumVariant;
  //we iterate through items
  while (Enumerator.Next(1,OleObject,ReturnNumber) = S_OK) do
  begin
    //we get device...
    ObjectSetItem := IUnknown(OleObject) as SWbemObject;
    //...then, get property set...
    PropertySet := ObjectSetItem.Properties_;
    //...and get properties iterator
    PropertyEnumerator := (PropertySet._NewEnum) as IEnumVariant;
    //here we iterate over device properties
    while (PropertyEnumerator.Next(1,OleObject,ReturnNumber) = S_OK) do
    begin
      DeviceProperty := IUnknown(OleObject) as SWbemProperty;
      self.SetDeviceProperty(DeviceProperty);
    end; //while for properties
  end; //while for devices
end; //procedure

{Class constructor. Gets info about device}
constructor TDevice.Create(path: PChar);
var
  fHandle: THandle; //device file handle
begin
  inherited Create;
  //we open the whole device
  {
    CM_Locate_DevNode
    CM_Get_DevNode_Status - get device Запоминающее устройство для USB
    CM_Get_DevNode_Registry_Property
    CM_Get_Child
  }

  fHandle := CreateFile(PChar(Format(VolumeMask,[path[0]])),0,
    FILE_SHARE_READ or FILE_SHARE_WRITE,nil,
    OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,0);
  try
    if fHandle = INVALID_HANDLE_VALUE {invalid handle}
    then begin
      raise EDeviceException.Create(SysErrorMessage(GetLastError)); {opening failed}
    end //exception - invalid file
    else begin
      //getting device number
      fDeviceNumber := GetAPIDeviceNumber(fHandle);
      //getting all necessary info about volume
      GetAPIDeviceDescription(fDeviceNumber);
      //setting the first volume on device
      fDeviceVolumes := TList.Create;
    end; //success - file created
  finally
    try
      CloseHandle(fHandle);
    except //supress exception
    end;
  end;
end;