{Gets device description from STORAGE_DEVICE_DESCRIPTOR structure}
procedure TDevice.GetAPIDeviceDescription(fHandle: THandle);
var
  DeviceDescriptor: STORAGE_DEVICE_DESCRIPTOR; {system device descriptor}
  ReturnedBytes: DWORD; {buffer for returned bytes}
  PropQuery: STORAGE_PROPERTY_QUERY; {property query}
  Success: LongBool; {indicates if a function call was successful}
  //hDev: THandle; {}
  DskSize: GET_LENGTH_INFORMATION;
begin
    //zero memofy for pointers
    ZeroMemory(@PropQuery, sizeof(PropQuery));
    ZeroMemory(@DeviceDescriptor, sizeof(DeviceDescriptor));
    //getting size of structure
    DeviceDescriptor.Size := sizeof(DeviceDescriptor);
    //we call DeviceIOControl to get info about the device
    //Returned bytes has no meaning in this case
    Success := DeviceIoControl(fHandle,IOCTL_STORAGE_QUERY_PROPERTY,@PropQuery,
      sizeof(PropQuery), @DeviceDescriptor, DeviceDescriptor.Size,
      ReturnedBytes, nil);
    if not Success
    then begin
      raise EDeviceException.Create(SysErrorMessage(GetLastError));
    end {exception - no such device}
    else begin
      if (DeviceDescriptor.BusType = BusTypeUnknown) or
        (DeviceDescriptor.BusType = BusTypeMaxReserved)
      then begin
        raise EDeviceException.Create(SysErrorMessage(GetLastError)); //unknown bus type
      end {unknown bus type}
      else begin
        {Converting bus type to TBusType}
        fDeviceBusType := TDevice.StorageBusTypeToTBusType(DeviceDescriptor.BusType);
        {Getting vendor ID
        fVendorID := self.APICharArrayToPChar(DeviceDescriptor,
          DeviceDescriptor.VendorIdOffset);}
        {Getting product revision
        fProductRevision := self.APICharArrayToPChar(DeviceDescriptor,
          DeviceDescriptor.ProductRevisionOffset);}
        {Getting product ID
        fProductID := self.APICharArrayToPChar(DeviceDescriptor,
          DeviceDescriptor.ProductIdOffset);}
      end;
    end;
    ZeroMemory(@PropQuery, sizeof(PropQuery));
    ZeroMemory(@DeviceDescriptor, sizeof(DeviceDescriptor));
end;




//This function gets device serial number
function TDevice.GetAPISerialNumber(devNumber: Cardinal): PChar;
var
  devHandle: THandle; //device handle
  diskSerialData: MEDIA_SERIAL_NUMBER_DATA; //structure for disk serial data
  Success: LongBool; //boolean flag
  ReturnedBytes: Cardinal; //bytes returned by DeviceIoControl
begin
  Result := '';
  //we open device as file
  devHandle := CreateFile(PChar(DrivePattern+IntToStr(devNumber)),
    0, FILE_SHARE_READ or FILE_SHARE_WRITE, nil, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
  try
    if devHandle = INVALID_HANDLE_VALUE
    then begin
      raise EDeviceException.Create(SysErrorMessage(GetLastError));
    end //opening failed
    else begin
      //here we try to get device serial number
      Success := DeviceIoControl(devHandle,IOCTL_STORAGE_GET_MEDIA_SERIAL_NUMBER,
        nil, 0, @diskSerialData, sizeof(diskSerialData), ReturnedBytes, nil);
      if not Success
      then begin
        raise EDeviceException.Create(SysErrorMessage(GetLastError));
      end //function invoke failed
      else begin
        Result := PChar(@diskSerialData.SerialNumberData);
      end; //successfully invoked
    end; //opening succeeded
  finally
    try
      CloseHandle(devHandle);
    except //handle already closed
    end; //exception supression
  end; //finally
end;

{Converts char arrays to PChar}
function TDevice.APICharArrayToPChar(DeviceDescriptor: STORAGE_DEVICE_DESCRIPTOR;
  offset: Cardinal): PChar;
var
  buf: PChar; {string for buffer}
begin
  Result := '';
  if offset <> 0
  then begin
    buf := @PCharArray(@DeviceDescriptor)^[offset];
    Result := PChar(Trim(buf));
  end;
end;


//Converts integer codes to TBusType enumeration
class function TDevice.StorageBusTypeToTBusType(sBusType: STORAGE_BUS_TYPE): TBusType;
begin
  Result := btUnknown;
  case sBusType of
    BusTypeScsi: Result := btSCSI;
    BusTypeAtapi: Result := btATAPI;
    BusTypeAta: Result := btATA;
    BusType1394: Result := btFireWire;
    BusTypeSsa: Result := btSSA;
    BusTypeFibre: Result := btFibre;
    BusTypeUsb: Result := btUSB;
    BusTypeRAID: Result := btRAID;
    BusTypeiSCSI: Result := btiSCSI;
    BusTypeSas: Result := btSAS;
    BusTypeSata: Result := btSATA;
  end;
end;


//This function gets all logical drives in system
procedure TDeviceManager.GetDrives;
const
  charCount = 4; //four characters describe each drive, e.g.: c:\<null-term>
var
  drives: PAnsiChar; //buffer for driver strings
  pDrives: Pointer; //pointer to the drives array
  bufSize: DWORD; //size of buffer
  i: integer; //counter
  driveNumber: integer; //number of drives
  sizeOfChar: integer; {size of 1 character in bytes:
                       (ANSI - 1 byte, Unicode - 2 bytes)}
begin

  {
    //here we get size needed for buffer
    bufSize := GetLogicalDriveStrings(0,nil);
    if bufSize<>0
    then begin //everything is OK
      drives := AllocMem(bufSize); //we alloc memory
      pDrives := drives; //save pointer to the beginning of the array
      GetLogicalDriveStrings(bufSize,drives);
      sizeOfChar := sizeof(drives[0]);
      driveNumber := (bufSize-1) div charCount; //we count the quantity of drives
      for i := 1 to driveNumber do
      begin
        if FilterDevices(drives)
        then begin
          fDevices.Add(TDevice.Create(drives))
        end; //filter
        drives := drives + charCount*sizeOfChar;  //move to the next list item
      end; //drives
      FreeMem(pDrives,bufSize); //we release resources
    end //bufSize<>0
    else begin
      raise EDeviceException.Create('Initialization failed!');
    end; //Raise
  }
end; //GetDrives


