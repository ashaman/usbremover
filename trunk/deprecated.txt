//This function gets device serial number
function TDevice.GetAPISerialNumber(devNumber: Cardinal): PChar;
var
  devHandle: THandle; //device handle
  diskSerialData: MEDIA_SERIAL_NUMBER_DATA; //structure for disk serial data
  Success: LongBool; //boolean flag
  ReturnedBytes: Cardinal; //bytes returned by DeviceIoControl
begin
  Result := '';
  //we open device as file
  devHandle := CreateFile(PChar(DrivePattern+IntToStr(devNumber)),
    0, FILE_SHARE_READ or FILE_SHARE_WRITE, nil, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
  try
    if devHandle = INVALID_HANDLE_VALUE
    then begin
      raise EDeviceException.Create(SysErrorMessage(GetLastError));
    end //opening failed
    else begin
      //here we try to get device serial number
      Success := DeviceIoControl(devHandle,IOCTL_STORAGE_GET_MEDIA_SERIAL_NUMBER,
        nil, 0, @diskSerialData, sizeof(diskSerialData), ReturnedBytes, nil);
      if not Success
      then begin
        raise EDeviceException.Create(SysErrorMessage(GetLastError));
      end //function invoke failed
      else begin
        Result := PChar(@diskSerialData.SerialNumberData);
      end; //successfully invoked
    end; //opening succeeded
  finally
    try
      CloseHandle(devHandle);
    except //handle already closed
    end; //exception supression
  end; //finally
end;

//Converts integer codes to TBusType enumeration
class function TDevice.StorageBusTypeToTBusType(sBusType: STORAGE_BUS_TYPE): TBusType;
begin
  Result := btUnknown;
  case sBusType of
    BusTypeScsi: Result := btSCSI;
    BusTypeAtapi: Result := btATAPI;
    BusTypeAta: Result := btATA;
    BusType1394: Result := btFireWire;
    BusTypeSsa: Result := btSSA;
    BusTypeFibre: Result := btFibre;
    BusTypeUsb: Result := btUSB;
    BusTypeRAID: Result := btRAID;
    BusTypeiSCSI: Result := btiSCSI;
    BusTypeSas: Result := btSAS;
    BusTypeSata: Result := btSATA;
  end;
end;


//This function gets all logical drives in system
procedure TDeviceManager.GetDrives;
const
  charCount = 4; //four characters describe each drive, e.g.: c:\<null-term>
var
  drives: PAnsiChar; //buffer for driver strings
  pDrives: Pointer; //pointer to the drives array
  bufSize: DWORD; //size of buffer
  i: integer; //counter
  driveNumber: integer; //number of drives
  sizeOfChar: integer; {size of 1 character in bytes:
                       (ANSI - 1 byte, Unicode - 2 bytes)}
begin

  {
    //here we get size needed for buffer
    bufSize := GetLogicalDriveStrings(0,nil);
    if bufSize<>0
    then begin //everything is OK
      drives := AllocMem(bufSize); //we alloc memory
      pDrives := drives; //save pointer to the beginning of the array
      GetLogicalDriveStrings(bufSize,drives);
      sizeOfChar := sizeof(drives[0]);
      driveNumber := (bufSize-1) div charCount; //we count the quantity of drives
      for i := 1 to driveNumber do
      begin
        if FilterDevices(drives)
        then begin
          fDevices.Add(TDevice.Create(drives))
        end; //filter
        drives := drives + charCount*sizeOfChar;  //move to the next list item
      end; //drives
      FreeMem(pDrives,bufSize); //we release resources
    end //bufSize<>0
    else begin
      raise EDeviceException.Create('Initialization failed!');
    end; //Raise
  }
end; //GetDrives

{
//This function gets all logical drives in system
procedure TDeviceManager.GetDrives;
var
  devInfo: THandle; //device info handle
  devInfoData: TSPDevInfoData; //device info
  devInterfaceData: TSPDeviceInterfaceData; //device interface info
  devInterfaceDefailData: TSPDeviceInterfaceDetailData; //concrete info
  i: integer; //counter
  dwSize: Cardinal; //dummy integer
begin
  //First, we get all disk devices in the system. Then, we choose
  //which are removable and then add them to the device list
  devInfo := SetupDiGetClassDevsA(@GUID_DEVCLASS_DISKDRIVE, nil, HWND(nil),
    DIGCF_PRESENT or DIGCF_DEVICEINTERFACE);
  if devInfo = INVALID_HANDLE_VALUE
  then begin
  end //then
  else begin
    i := 0;
    devInterfaceData.cbSize := sizeof(devInterfaceData);
    while (SetupDiEnumDeviceInterfaces(devInfo,nil,GUID_DEVCLASS_DISKDRIVE,
      i,devInterfaceData)) do
    begin
      inc(i);
      SetupDiGetDeviceInterfaceDetailA(devInfo,@devInterfaceData,nil,0,dwSize,nil);
      if dwSize = 0
      then begin
      end //fail
      else begin
        devInfoData.cbSize := dwSize;
        devInterfaceDefailData.cbSize := 5;
        SetupDiGetDeviceInterfaceDetailA(devInfo,@devInterfaceData,
          @devInterfaceDefailData,dwSize,dwSize,nil);

          ////!!!!!!!!!!!Look for SafeRemove by Bagel
          //// the previous works good

      end;
    end; //while
  end; //else
end; //GetDrives}


function TDeviceManager.GetLogicalDrives(const Volumes: TStrings): TStrings;
var
  dummy: Cardinal;
  s: string;
  handle: THandle;
  buf: TVolumeDiskExtents;
  i: integer;
begin


  for i := 0 to Volumes.Count-1 do
  begin
    s := Volumes.Strings[i];
    s[3] := '.';
    Delete(s,Length(s),1);
    handle := CreateFile(PChar(s),GENERIC_READ, FILE_SHARE_READ
      or FILE_SHARE_WRITE, nil, OPEN_EXISTING, 0, 0);
    if handle <> INVALID_HANDLE_VALUE
    then begin
      if DeviceIoControl(handle,IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS, nil,0,
        @buf,sizeof(buf),dummy,nil)
      then begin
        dummy := buf.Extents[0].DiskNumber;
      end;
      CloseHandle(handle);
    end;
  end;
end;


unit Device;

interface
uses
  WinIOCtl, Classes, WbemScripting_TLB;

type
  {all kinds of devices defined in WinAPI enums}
  TBusType = (btSCSI, btATAPI, btATA, btFireWire, btSSA, btFibre, btUSB,
  btRAID, btiSCSI, btSAS, btSATA, btUnknown);

  //CLASS-WRAPPER FOR DEVICE
  TDevice = class(TObject)
  private
    fDeviceID: string; //device ID
    fDeviceNumber: Cardinal; //device number in system
    fDeviceNumberOfPartitions: integer; //number of drive partitions
    fDeviceManufacturer: string; //device manufacturer
    fDeviceModel: string; //device model
    fDeviceBusType: string; //device bus type
    fDeviceName: string; //device name
    fDeviceVolumes: TList; //device volume
    //These functions get disk partition information and its device number
    class function GetAPIDeviceNumber(fHandle: THandle): Cardinal;
    procedure GetAPIDeviceDescription(devNumber: Cardinal);
    procedure SetDeviceProperty(devProperty: ISWbemProperty);
    {getters}
    function GetDeviceID: string;
    function GetDeviceNumber: Cardinal;
    function GetDeviceNumberOfPartitions: Integer;
    function GetDeviceManufacturer: string;
    function GetDeviceModel: string;
    function GetBusType: string;
    function GetDeviceName: string;
    {end getters}
  public
    constructor Create(path: PChar);
    destructor Destroy; override;
    //properties
    property DeviceID: string read GetDeviceID; {Device ID}
    property DeviceNumber: Cardinal read GetDeviceNumber; {physical drive number}
    property DeviceNumberOfPartitions: integer read GetDeviceNumberOfPartitions; {number of partitions}
    property DeviceManufacturer: string read GetDeviceManufacturer; {device manufacturer}
    property DeviceModel: string read GetDeviceModel; {Model}
    property DeviceBusType: string read GetBusType; {Bus type}
    property DeviceName: string read GetDeviceName; {Name}
  end;

{==============================================================================}
implementation
uses
  Windows, DeviceException, SysUtils, WMI, OleServer, ActiveX;

//This function gets device number
class function TDevice.GetAPIDeviceNumber(fHandle: THandle): Cardinal;
var
  Success: LongBool; //boolean flag
  devNumber: TStorageDeviceNumber; //structure which describes device number
  ReturnedBytes: Cardinal; //bytes returned by DeviceIoControl
begin
  //call DeviceIOControl
  Success := DeviceIoControl(fHandle,IOCTL_STORAGE_GET_DEVICE_NUMBER,
    nil, 0, @devNumber, sizeof(TStorageDeviceNumber), ReturnedBytes, nil);
  if not Success
  then begin
    raise EDeviceException.Create(SysErrorMessage(GetLastError));
  end //getting device number failed
  else begin
    Result := devNumber.DeviceNumber;
  end; //successful
end;

//gets property name and sets the value
procedure TDevice.SetDeviceProperty(devProperty: ISWbemProperty);
begin
  if devProperty.Name = 'DeviceID'
  then begin
    fDeviceID := devProperty.Get_Value;
    exit;
  end;
  if devProperty.Name = 'InterfaceType'
  then begin
    fDeviceBusType := devProperty.Get_Value;
    exit;
  end;
  if devProperty.Name = 'Manufacturer'
  then begin
    fDeviceManufacturer := devProperty.Get_Value;
    exit;
  end;
  if devProperty.Name = 'Model'
  then begin
    fDeviceModel := devProperty.Get_Value;
    exit;
  end;
  if devProperty.Name = 'Name'
  then begin
    fDeviceName := devProperty.Get_Value;
    exit;
  end;
  if devProperty.Name = 'Partitions'
  then begin
    fDeviceNumberOfPartitions := Cardinal(devProperty.Get_Value);
    exit;
  end;
  {
    if devProperty.Name = 'PNPDeviceID'
    then begin
      buf := TStringList.Create;
      ExtractStrings(['\','&'],[], PChar(string(devProperty.Get_Value)), buf);
      exit;
    end;
    //string SerialNumber; not supported on XP
    //uint64 Size;
    //string Caption;
    //string Description;
    //string FirmwareRevision; not available on XP
  }
end;

{Gets device description from WMI}
procedure TDevice.GetAPIDeviceDescription(devNumber: Cardinal);
var
  Locator: TSWbemLocator; //OLE provider
  Services: ISWbemServices; //namespace objects
  ObjectSet:  ISWbemObjectSet; //query result - set of objects
  ObjectSetItem: ISWbemObject; //item of the ObjectSet
  Enumerator: IEnumVariant; //device enumerator
  PropertyEnumerator: IEnumVariant; //device properties enumerator
  PropertySet: ISWbemPropertySet; //device properties set
  OleObject: OleVariant; //buffer for getting device info
  DeviceProperty: ISWbemProperty; //device property
  ReturnNumber: Cardinal; //return parameter of procedure call
begin
  //we create OLE provider
  Locator := TSWbemLocator.Create(nil);
  //we connect to the local computer namespace
  Services := Locator.ConnectServer('.','root\CIMV2','','','','',0,nil);
  //we execute query to get the only device we need
  ObjectSet := Services.ExecQuery('SELECT * FROM Win32_DiskDrive WHERE DeviceID="'+
    Format(DrivePattern,[devNumber])+'"','WQL',wbemFlagReturnImmediately
    and wbemFlagForwardOnly, nil);
  //we get the device enumerator
  Enumerator := (ObjectSet._NewEnum) as IEnumVariant;
  //we iterate through items
  while (Enumerator.Next(1,OleObject,ReturnNumber) = S_OK) do
  begin
    //we get device...
    ObjectSetItem := IUnknown(OleObject) as SWbemObject;
    //...then, get property set...
    PropertySet := ObjectSetItem.Properties_;
    //...and get properties iterator
    PropertyEnumerator := (PropertySet._NewEnum) as IEnumVariant;
    //here we iterate over device properties
    while (PropertyEnumerator.Next(1,OleObject,ReturnNumber) = S_OK) do
    begin
      DeviceProperty := IUnknown(OleObject) as SWbemProperty;
      self.SetDeviceProperty(DeviceProperty);
    end; //while for properties
  end; //while for devices
end; //procedure

{Class constructor. Gets info about device}
constructor TDevice.Create(path: PChar);
var
  fHandle: THandle; //device file handle
begin
  inherited Create;
  //we open the whole device
  {
    CM_Locate_DevNode
    CM_Get_DevNode_Status - get device Запоминающее устройство для USB
    CM_Get_DevNode_Registry_Property
    CM_Get_Child
  }

  fHandle := CreateFile(PChar(Format(VolumeMask,[path[0]])),0,
    FILE_SHARE_READ or FILE_SHARE_WRITE,nil,
    OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,0);
  try
    if fHandle = INVALID_HANDLE_VALUE {invalid handle}
    then begin
      raise EDeviceException.Create(SysErrorMessage(GetLastError)); {opening failed}
    end //exception - invalid file
    else begin
      //getting device number
      fDeviceNumber := GetAPIDeviceNumber(fHandle);
      //getting all necessary info about volume
      GetAPIDeviceDescription(fDeviceNumber);
      //setting the first volume on device
      fDeviceVolumes := TList.Create;
    end; //success - file created
  finally
    try
      CloseHandle(fHandle);
    except //supress exception
    end;
  end;
end;

  {
  DeviceInfo.cbSize := sizeof(SP_DEVINFO_DATA);
  DrivesPnpHandle := SetupDiGetClassDevsA(@GUID_DEVCLASS_DISKDRIVE, nil,
    HWND(nil), DIGCF_PRESENT);
  try
    if DrivesPnpHandle = INVALID_HANDLE_VALUE
    then begin
      raise EDeviceException.Create(SysErrorMessage(GetLastError));
    end //invalid handle
    else begin
      //works improperly too
      if not SetupDiEnumDeviceInfo(DrivesPnpHandle,device.DeviceNumber,DeviceInfo)
      then begin
        raise EDeviceException.Create(SysErrorMessage(GetLastError));
      end //end error SetupDiEnum...
      else begin
        if CM_Get_Parent(Parent, DeviceInfo.DevInst, 0) = CR_SUCCESS
        then begin
          CM_Request_Device_EjectA(Parent,nil,@VetoName,MAX_PATH,0);
          if VetoName = ''
          then begin
            for i := 0 to device.DeviceNumberOfPartitions-1 do
            begin
            end;
            //AIIIIO! AIO YOI O?OUUUU!!!!
            //TODO: Refactor this code and add BlockedFiles search
                  //Check if there's any possibility to switch on
                  //disconnected device

            //SHChangeNotify(SHCNE_MEDIAREMOVED,SHCNF_PATH,device.Path,nil);
          end
          else begin
          end;
        end; //end CM_GET_PARENT
      end; //end SetupDiEnum...
    end; //valid handle
  finally
    SetupDiDestroyDeviceInfoList(DrivesPnpHandle);
  end;              }


{
  WARINING: OLD VERSION. DOES NOT INFORM WINDOWS PROPERLY

  !!!uses ShlObj, ShellAPI

//Main method for drive removal
procedure TUSBManager.RemoveDrive(device: TDevice);
var
  Success: LongBool;
  i: integer;
  ReturnedBytes: DWORD;
  PreventFlag: PREVENT_MEDIA_REMOVAL;
  fHandle: THandle;
begin
  for i := 0 to MAX_ATTEMPTS-1 do
  begin
    //here we try to lock the volume
    Success := DeviceIoControl(fHandle, FSCTL_LOCK_VOLUME, nil, 0, nil, 0,
      ReturnedBytes, nil);
    if not Success
    then begin
      if i = MAX_ATTEMPTS-1
      then begin
        raise EDeviceException.Create(SysErrorMessage(GetLastError)); //access
      end //no more attempts left                                    //denied!
      else begin
        Sleep(2000);
        continue;
      end; //skip the iteration
    end //not successful
    else begin
      //clear the memory
      ZeroMemory(@PreventFlag, sizeof(PreventFlag));
      //we dismount the volume...
      DeviceIoControl(fHandle,FSCTL_DISMOUNT_VOLUME, nil, 0, nil, 0,
        ReturnedBytes, nil);
      //then, we enable volume ejection mechanism...
      DeviceIoControl(fHandle,IOCTL_STORAGE_MEDIA_REMOVAL,@PreventFlag,
        sizeof(PreventFlag),nil,0,ReturnedBytes,nil);
      //after, we eject the volume...
      DeviceIoControl(fHandle,IOCTL_STORAGE_EJECT_MEDIA, nil, 0, nil, 0,
        ReturnedBytes,nil);
      //...and finally we release the device
      DeviceIoControl(fHandle,FSCTL_UNLOCK_VOLUME,nil,0,nil,0,
        ReturnedBytes,nil);
      //...notify system about device removal..
      SHChangeNotify(SHCNE_MEDIAREMOVED,SHCNF_PATH,device.Path,nil);
      //and release all resources
      device.Destroy;
      fDevices.Pack;
      break;
    end; //successful
  end;
end;
}